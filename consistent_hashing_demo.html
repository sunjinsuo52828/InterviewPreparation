<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consistent Hashing Visualization</title>
    <style>
        :root {
            --primary: #2196F3;
            --success: #4CAF50;
            --danger: #F44336;
            --dark: #333;
            --light: #f5f5f5;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #f0f2f5;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
            box-sizing: border-box;
        }
        h1 { text-align: center; margin: 0 0 20px 0; color: var(--dark); }
        
        .main-layout {
            display: flex;
            flex: 1;
            gap: 20px;
            overflow: hidden;
        }

        /* Left: Controls & Stats */
        .panel-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
        }
        .card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .card h3 { margin-top: 0; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        
        button {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }
        .btn-add { background: var(--success); color: white; }
        .btn-remove { background: var(--danger); color: white; }
        .btn-data { background: var(--primary); color: white; }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; }
        .stat-val { font-weight: bold; }

        /* Center: Ring Visualization */
        .panel-center {
            flex: 2;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        #ring-container {
            position: relative;
            width: 500px;
            height: 500px;
        }
        
        /* SVG Layer */
        svg {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
        }
        #ring-svg {
            transform: rotate(-90deg); /* Start at top */
            z-index: 1;
        }
        #interaction-svg {
            z-index: 20; /* Above dots */
            pointer-events: none; /* Let clicks pass through to dots */
        }
        
        .node-dot {
            position: absolute;
            width: 24px; height: 24px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            font-weight: bold;
            transition: all 0.3s;
            cursor: pointer; /* Add cursor */
        }
        .node-dot:hover { transform: translate(-50%, -50%) scale(1.2); z-index: 30; }

        .node-dot.virtual {
            width: 12px; height: 12px;
            opacity: 0.8;
            font-size: 0;
            border: 1px solid white;
        }
        
        .key-dot {
            position: absolute;
            width: 8px; height: 8px;
            background: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            transition: all 0.5s ease-in-out;
            cursor: pointer; /* Add cursor */
        }
        .key-dot:hover { transform: translate(-50%, -50%) scale(2); z-index: 30; }

        .key-dot.moving {
            width: 12px; height: 12px;
            background: #FFD700; /* Gold */
            box-shadow: 0 0 10px #FFD700;
            z-index: 20;
        }

        /* Right: Load Distribution */
        .panel-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 250px;
        }
        
        .bar-chart {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bar-row { display: flex; align-items: center; gap: 10px; }
        .bar-label { width: 60px; font-size: 12px; text-align: right; }
        .bar-track { flex: 1; background: #eee; height: 20px; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.5s; display: flex; align-items: center; padding-left: 5px; color: white; font-size: 10px; }

        .log-panel {
            flex: 1;
            background: #263238;
            color: #eceff1;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #37474f; padding-bottom: 2px; }
        .log-highlight { color: #FFD700; }

        /* Modal Styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.5); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 10% auto; 
            padding: 20px;
            border: 1px solid #888;
            width: 80%; 
            max-width: 800px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .tutorial-step {
            margin-bottom: 20px;
            padding: 15px;
            background: #f9f9f9;
            border-left: 4px solid var(--primary);
            border-radius: 4px;
        }
        .tutorial-step h4 { margin-top: 0; color: var(--primary); }

    </style>
</head>
<body>

    <h1>Consistent Hashing Ring (ä¸€è‡´æ€§å“ˆå¸Œ)</h1>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHelp()">&times;</span>
            <h2>ğŸ“– ç®—æ³•åŸç† (Algorithm Explanation)</h2>
            
            <div class="tutorial-step">
                <h4>1. å“ˆå¸Œç¯ (The Ring)</h4>
                <p>æƒ³è±¡ä¸€ä¸ªé—­åˆçš„ç¯ï¼Œä»£è¡¨å“ˆå¸Œç©ºé—´ $0$ åˆ° $2^{32}-1$ã€‚æˆ‘ä»¬å°†è¿™ä¸ªçº¿æ€§ç©ºé—´é¦–å°¾ç›¸è¿ã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>2. èŠ‚ç‚¹æ˜ å°„ (Node Placement)</h4>
                <p>æœåŠ¡å™¨èŠ‚ç‚¹ (Node) é€šè¿‡å“ˆå¸Œå‡½æ•° (å¦‚ `hash(IP)`) æ˜ å°„åˆ°ç¯ä¸Šçš„æŸä¸ªä½ç½®ã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>3. æ•°æ®å®šä½ (Key Routing)</h4>
                <p>æ•°æ®å¯¹è±¡ (Key) ä¹Ÿé€šè¿‡ç›¸åŒçš„å“ˆå¸Œå‡½æ•°æ˜ å°„åˆ°ç¯ä¸Šã€‚è¦æ‰¾åˆ°æ•°æ®å½’å±çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ä»æ•°æ®çš„ä½ç½®å¼€å§‹ï¼Œ<b>é¡ºæ—¶é’ˆ (Clockwise)</b> æŸ¥æ‰¾ï¼Œé‡åˆ°çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å®ƒçš„å½’å±ã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>4. è™šæ‹ŸèŠ‚ç‚¹ (Virtual Nodes)</h4>
                <p>å¦‚æœèŠ‚ç‚¹å¤ªå°‘ï¼Œæ•°æ®åˆ†å¸ƒå¯èƒ½ä¸å‡åŒ€ (Data Skew)ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªçœŸå®èŠ‚ç‚¹åˆ›å»ºå¤šä¸ªâ€œè™šæ‹ŸèŠ‚ç‚¹â€åˆ†å¸ƒåœ¨ç¯ä¸Šã€‚è¿™ä½¿å¾—æ•°æ®æ›´å‡åŒ€åœ°åˆ†æ•£åˆ°å„ä¸ªçœŸå®èŠ‚ç‚¹ã€‚</p>
            </div>
        </div>
    </div>

    <!-- Interview Modal -->
    <div id="interviewModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeInterview()">&times;</span>
            <h2>ğŸ“ é¢è¯•æ ¸å¿ƒè€ƒç‚¹ (Interview Key Points)</h2>
            
            <div class="tutorial-step">
                <h4>1. ä¸ºä»€ä¹ˆè¦ç”¨ä¸€è‡´æ€§å“ˆå¸Œ? (Why?)</h4>
                <p><b>ä¼ ç»Ÿå“ˆå¸Œ (hash % N)</b>: å½“èŠ‚ç‚¹æ•° N å˜åŒ–æ—¶ï¼Œå‡ ä¹æ‰€æœ‰æ•°æ®éƒ½éœ€è¦è¿ç§»ï¼Œå¯¼è‡´ç¼“å­˜é›ªå´©ã€‚</p>
                <p><b>ä¸€è‡´æ€§å“ˆå¸Œ</b>: åªæœ‰ç¯ä¸Šçš„ä¸€å°æ®µæ•°æ®éœ€è¦è¿ç§» (çº¦ $1/N$)ï¼Œä¿è¯äº†ç³»ç»Ÿçš„<b>å•è°ƒæ€§ (Monotonicity)</b>ã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>2. è™šæ‹ŸèŠ‚ç‚¹çš„ä½œç”¨? (Virtual Nodes)</h4>
                <p><b>è§£å†³æ•°æ®å€¾æ–œ (Data Skew)</b>: èŠ‚ç‚¹å°‘æ—¶ï¼Œæ•°æ®å®¹æ˜“é›†ä¸­åœ¨æŸä¸€ä¸ªèŠ‚ç‚¹ã€‚è™šæ‹ŸèŠ‚ç‚¹å°†ç‰©ç†èŠ‚ç‚¹åˆ‡åˆ†ä¸ºå¤šä¸ªå°ç‚¹å‡åŒ€åˆ†å¸ƒã€‚</p>
                <p><b>å¤„ç†å¼‚æ„èŠ‚ç‚¹</b>: æ€§èƒ½å¼ºçš„æœºå™¨å¯ä»¥åˆ†é…æ›´å¤šçš„è™šæ‹ŸèŠ‚ç‚¹ (æƒé‡è°ƒæ•´)ã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>3. å¸¸è§å“ˆå¸Œç®—æ³•? (Hash Algorithms)</h4>
                <p>é€šå¸¸ä½¿ç”¨ <b>MurmurHash</b> (é«˜æ€§èƒ½) æˆ– <b>MD5</b> (å‡åŒ€æ€§å¥½)ã€‚Java `HashMap` é»˜è®¤çš„ hashCode ä¸å¤Ÿå‡åŒ€ï¼Œä¸é€‚åˆç›´æ¥ç”¨äºä¸€è‡´æ€§å“ˆå¸Œã€‚</p>
            </div>

            <div class="tutorial-step">
                <h4>4. å®é™…åº”ç”¨åœºæ™¯? (Real-world Usage)</h4>
                <ul>
                    <li><b>åˆ†å¸ƒå¼ç¼“å­˜</b>: Memcached å®¢æˆ·ç«¯ (å¦‚ Spymemcached)ã€‚</li>
                    <li><b>NoSQL æ•°æ®åº“</b>: Amazon DynamoDB, Apache Cassandra (ä½¿ç”¨ Token Ring)ã€‚</li>
                    <li><b>è´Ÿè½½å‡è¡¡</b>: Nginx (`ip_hash`), Google Maglevã€‚</li>
                </ul>
            </div>
        </div>
    </div>

    <svg style="width:0;height:0;position:absolute;" aria-hidden="true" focusable="false">
        <defs>
            <marker id="arrowhead" markerWidth="10" markerHeight="7" 
            refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#333" />
            </marker>
        </defs>
    </svg>

    <div class="main-layout">
        <!-- Left Panel -->
        <div class="panel-left">
            <div class="card">
                <h3>ğŸ› ï¸ æ§åˆ¶å° (Controls)</h3>
                <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button style="background: #607D8B; color: white; flex: 1; margin-bottom: 0;" onclick="openHelp()">â“ ç®—æ³•åŸç†</button>
                    <button style="background: #9C27B0; color: white; flex: 1; margin-bottom: 0;" onclick="openInterview()">ğŸ“ é¢è¯•è€ƒç‚¹</button>
                </div>
                <button class="btn-add" onclick="addNode()">â• æ·»åŠ èŠ‚ç‚¹ (Add Node)</button>
                <button class="btn-remove" onclick="removeNode()">â– ç§»é™¤èŠ‚ç‚¹ (Remove Node)</button>
                <button class="btn-data" onclick="addKeys(50)">ğŸ”‘ æ³¨å…¥æ•°æ® (Add 50 Keys)</button>
                
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                    <label style="display:flex; align-items:center; gap:10px; cursor:pointer;">
                        <input type="checkbox" id="vnode-toggle" onchange="toggleVNodes()">
                        <span>å¯ç”¨è™šæ‹ŸèŠ‚ç‚¹ (Virtual Nodes)</span>
                    </label>
                    <p style="font-size: 12px; color: #666; margin-top: 5px;">
                        æ¯ä¸ªçœŸå®èŠ‚ç‚¹å°†æ˜ å°„ä¸º 10 ä¸ªè™šæ‹ŸèŠ‚ç‚¹ï¼Œè§£å†³æ•°æ®å€¾æ–œé—®é¢˜ã€‚
                    </p>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“Š ç»Ÿè®¡ (Statistics)</h3>
                <div class="stat-row">
                    <span>Total Nodes:</span>
                    <span class="stat-val" id="stat-nodes">0</span>
                </div>
                <div class="stat-row">
                    <span>Total Keys:</span>
                    <span class="stat-val" id="stat-keys">0</span>
                </div>
                <div class="stat-row">
                    <span>Standard Deviation (Skew):</span>
                    <span class="stat-val" id="stat-stddev">0</span>
                </div>
                <div class="stat-row" style="margin-top: 10px; color: var(--primary);">
                    <span>Last Migration:</span>
                    <span class="stat-val" id="stat-migration">0 keys</span>
                </div>
                <p style="font-size: 11px; color: #888;">
                    * Standard Deviation è¶Šä½ï¼Œè´Ÿè½½è¶Šå‡è¡¡ã€‚
                </p>
            </div>
        </div>

        <!-- Center Panel -->
        <div class="panel-center">
            <div id="ring-container">
                <svg id="ring-svg"></svg>
                <svg id="interaction-svg"></svg>
                <!-- Nodes and Keys injected here -->
            </div>
            <div style="position: absolute; bottom: 20px; text-align: center; color: #666; font-size: 12px;">
                Hash Space: $0$ to $2^{32}-1$ (Mapped to $0^{\circ}-360^{\circ}$)<br>
                <span style="color: var(--primary); font-weight: bold;">Tip: Hover over any dot to see its binding!</span>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="panel-right">
            <div class="card">
                <h3>âš–ï¸ è´Ÿè½½åˆ†å¸ƒ (Load Balance)</h3>
                <div id="load-chart" class="bar-chart">
                    <!-- Bars injected here -->
                </div>
            </div>
            
            <div class="log-panel" id="log">
                <div class="log-entry">> System Initialized.</div>
            </div>
        </div>
    </div>

    <script>
        window.onerror = function(msg, url, line) {
            alert("Javascript Error: " + msg + "\nLine: " + line);
        };

        // --- Config ---
        const RING_SIZE = 500;
        const RADIUS = 200;
        const CENTER = 250;
        const VNODE_COUNT = 10; // Virtual nodes per real node
        const COLORS = ['#F44336', '#9C27B0', '#3F51B5', '#009688', '#FF9800', '#795548', '#E91E63', '#673AB7'];

        // --- State ---
        let nodes = []; // { id, color, angle, isVirtual, parentId }
        let keys = [];  // { id, angle, ownerId }
        let nodeIdCounter = 1;
        let useVNodes = false;

        // --- Core Logic ---

        function getHash(str) {
            // Simple hash for demo: string -> 0-360
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return Math.abs(hash) % 360;
        }

        function addNode() {
            const id = `N${nodeIdCounter++}`;
            const color = COLORS[nodes.filter(n => !n.isVirtual).length % COLORS.length];
            
            // Add Real Node
            // For demo visual clarity, we try to place real nodes somewhat randomly but not too close if possible,
            // or just purely random. Pure random is more realistic for hashing.
            const angle = Math.floor(Math.random() * 360);
            
            const newNodes = [];
            newNodes.push({ id, color, angle, isVirtual: false, parentId: id });

            // Add Virtual Nodes if enabled
            if (useVNodes) {
                for (let i = 0; i < VNODE_COUNT; i++) {
                    newNodes.push({
                        id: `${id}#${i}`,
                        color,
                        angle: Math.floor(Math.random() * 360),
                        isVirtual: true,
                        parentId: id
                    });
                }
            }

            nodes.push(...newNodes);
            nodes.sort((a, b) => a.angle - b.angle);
            
            rebalance(`Added Node ${id}`);
        }

        function removeNode() {
            const realNodes = nodes.filter(n => !n.isVirtual);
            if (realNodes.length === 0) return;
            
            const target = realNodes[Math.floor(Math.random() * realNodes.length)];
            
            // Remove target and all its virtual nodes
            nodes = nodes.filter(n => n.parentId !== target.parentId);
            
            rebalance(`Removed Node ${target.parentId}`);
        }

        function addKeys(count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.floor(Math.random() * 360);
                keys.push({
                    id: `k-${Date.now()}-${i}`,
                    angle,
                    ownerId: null // Will be set by rebalance
                });
            }
            rebalance(`Added ${count} Keys`);
        }

        function toggleVNodes() {
            useVNodes = document.getElementById('vnode-toggle').checked;
            
            // Re-generate nodes based on current real nodes
            const currentRealNodes = nodes.filter(n => !n.isVirtual).map(n => ({ id: n.parentId, color: n.color }));
            
            nodes = [];
            currentRealNodes.forEach(n => {
                // Re-add real node (random pos for demo variety or keep pos? Let's keep pos logic simple: random new pos)
                // Actually, to show the effect, we should probably keep real nodes where they are?
                // But VNodes are random. Let's just regenerate all positions for simplicity or keep real node pos?
                // Let's regenerate to ensure good distribution demo.
                
                const angle = Math.floor(Math.random() * 360);
                nodes.push({ id: n.id, color: n.color, angle, isVirtual: false, parentId: n.id });
                
                if (useVNodes) {
                    for (let i = 0; i < VNODE_COUNT; i++) {
                        nodes.push({
                            id: `${n.id}#${i}`,
                            color: n.color,
                            angle: Math.floor(Math.random() * 360),
                            isVirtual: true,
                            parentId: n.id
                        });
                    }
                }
            });
            
            nodes.sort((a, b) => a.angle - b.angle);
            rebalance("Toggled Virtual Nodes");
        }

        function rebalance(reason) {
            if (nodes.length === 0) {
                keys.forEach(k => k.ownerId = null);
                render();
                updateStats(0);
                log(reason);
                return;
            }

            let movedCount = 0;

            keys.forEach(k => {
                // Find first node clockwise
                let target = nodes.find(n => n.angle >= k.angle);
                if (!target) target = nodes[0]; // Wrap around
                
                const newOwner = target.parentId;
                if (k.ownerId !== newOwner) {
                    if (k.ownerId !== null) movedCount++; // Only count if it had an owner before
                    k.ownerId = newOwner;
                    k.targetAngle = target.angle; // For visual line
                }
            });

            render();
            updateStats(movedCount);
            log(`${reason}. Migration: ${movedCount} keys moved.`);
        }

        // --- Rendering ---

        function render() {
            const container = document.getElementById('ring-container');
            const svg = document.getElementById('ring-svg');
            const interactionSvg = document.getElementById('interaction-svg');
            
            if (!container || !svg || !interactionSvg) {
                console.error("Critical Error: DOM elements missing.");
                return;
            }
            
            // Clear DOM elements (except SVGs)
            // Fix: Check IDs to avoid removing SVGs (tagName can be 'svg' or 'SVG')
            Array.from(container.children).forEach(c => {
                if (c.id !== 'ring-svg' && c.id !== 'interaction-svg') c.remove();
            });
            svg.innerHTML = '';
            interactionSvg.innerHTML = ''; // Clear interactions

            // 1. Draw Ring Segments (Ownership Ranges)
            if (nodes.length > 0) {
                if (nodes.length === 1) {
                    // Special case: Single node owns the whole ring
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", CENTER);
                    circle.setAttribute("cy", CENTER);
                    circle.setAttribute("r", RADIUS);
                    circle.setAttribute("stroke", nodes[0].color);
                    circle.setAttribute("stroke-width", "10");
                    circle.setAttribute("fill", "none");
                    circle.setAttribute("opacity", "0.5");
                    svg.appendChild(circle);
                } else {
                    for (let i = 0; i < nodes.length; i++) {
                        const curr = nodes[i];
                        const prev = nodes[i === 0 ? nodes.length - 1 : i - 1];
                        
                        // Arc from prev.angle to curr.angle
                        let startAngle = prev.angle;
                        let endAngle = curr.angle;
                        if (i === 0) startAngle -= 360; // Wrap logic for first segment
                        
                        // Draw Arc
                        const path = describeArc(CENTER, CENTER, RADIUS, startAngle, endAngle);
                        const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        pathEl.setAttribute("d", path);
                        pathEl.setAttribute("fill", "none");
                        pathEl.setAttribute("stroke", curr.color);
                        pathEl.setAttribute("stroke-width", "10");
                        pathEl.setAttribute("opacity", "0.5");
                        svg.appendChild(pathEl);
                    }
                }
            } else {
                // Empty ring
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", CENTER);
                circle.setAttribute("cy", CENTER);
                circle.setAttribute("r", RADIUS);
                circle.setAttribute("stroke", "#ddd");
                circle.setAttribute("stroke-width", "4");
                circle.setAttribute("fill", "none");
                svg.appendChild(circle);
            }

            // 2. Draw Nodes
            nodes.forEach(n => {
                const pos = getPos(n.angle, RADIUS);
                const el = document.createElement('div');
                el.className = `node-dot ${n.isVirtual ? 'virtual' : ''}`;
                el.style.left = pos.x + 'px';
                el.style.top = pos.y + 'px';
                el.style.backgroundColor = n.color;
                if (!n.isVirtual) el.innerText = n.id;
                
                // Interaction
                el.onmouseenter = () => highlightNode(n);
                el.onmouseleave = () => clearHighlights();
                
                container.appendChild(el);
            });

            // 3. Draw Keys
            keys.forEach(k => {
                // Place key slightly inside the ring
                const pos = getPos(k.angle, RADIUS - 20);
                const el = document.createElement('div');
                el.className = 'key-dot';
                el.style.left = pos.x + 'px';
                el.style.top = pos.y + 'px';
                
                // Color key by owner
                const ownerNode = nodes.find(n => n.parentId === k.ownerId); // Just get color
                if (ownerNode) {
                    el.style.backgroundColor = ownerNode.color;
                } else {
                    el.style.backgroundColor = '#ccc';
                }
                
                // Interaction
                el.onmouseenter = () => highlightKey(k);
                el.onmouseleave = () => clearHighlights();
                
                container.appendChild(el);
            });
        }

        // --- Interaction Logic ---

        function highlightKey(key) {
            const svg = document.getElementById('interaction-svg');
            const keyPos = getPos(key.angle, RADIUS - 20);
            
            // Find owner node
            const owner = nodes.find(n => n.parentId === key.ownerId); // This might find any virtual node of the same parent
            // Actually we want the specific node (virtual or real) that owns this range.
            // The rebalance logic assigns ownerId (parentId). It doesn't store which specific virtual node caught it.
            // Let's re-calculate the specific target node for visualization.
            
            let target = nodes.find(n => n.angle >= key.angle);
            if (!target) target = nodes[0];
            
            if (target) {
                const nodePos = getPos(target.angle, RADIUS);
                
                // Draw Line
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", keyPos.x);
                line.setAttribute("y1", keyPos.y);
                line.setAttribute("x2", nodePos.x);
                line.setAttribute("y2", nodePos.y);
                line.setAttribute("stroke", "#333");
                line.setAttribute("stroke-width", "2");
                line.setAttribute("stroke-dasharray", "5,5");
                svg.appendChild(line);
                
                // Draw Clockwise Arrow (Arc)
                // From Key Angle to Node Angle
                // Note: describeArc expects 0 at top (handled by rotation in ring-svg).
                // But interaction-svg is NOT rotated.
                // So we need to adjust angles for describeArc if we use it here?
                // describeArc uses polarToCartesian which uses standard math (0 is Right).
                // Our angles are 0-360 where 0 is Top (because we rotated ring-svg).
                // So if key.angle is 0, it is visually at Top.
                // In standard math, Top is -90 (or 270).
                // So we need to subtract 90 from our angles when calling polarToCartesian for the non-rotated SVG.
                
                // Let's make a helper for non-rotated arc
                const path = describeArcNoRotate(CENTER, CENTER, RADIUS - 10, key.angle, target.angle);
                const pathEl = document.createElementNS("http://www.w3.org/2000/svg", "path");
                pathEl.setAttribute("d", path);
                pathEl.setAttribute("fill", "none");
                pathEl.setAttribute("stroke", target.color);
                pathEl.setAttribute("stroke-width", "3");
                pathEl.setAttribute("marker-end", "url(#arrowhead)");
                svg.appendChild(pathEl);
            }
        }

        function highlightNode(node) {
            const svg = document.getElementById('interaction-svg');
            const nodePos = getPos(node.angle, RADIUS);
            
            // Find all keys that map to THIS specific node instance (real or virtual)
            // We need to check the range this node covers.
            // Range is (PreviousNode.angle, ThisNode.angle]
            
            const nodeIndex = nodes.indexOf(node);
            const prevNode = nodes[nodeIndex === 0 ? nodes.length - 1 : nodeIndex - 1];
            
            let start = prevNode.angle;
            let end = node.angle;
            
            // Filter keys in this range
            const ownedKeys = keys.filter(k => {
                if (start < end) {
                    return k.angle > start && k.angle <= end;
                } else {
                    // Wrap around case
                    return k.angle > start || k.angle <= end;
                }
            });
            
            ownedKeys.forEach(k => {
                const keyPos = getPos(k.angle, RADIUS - 20);
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("x1", keyPos.x);
                line.setAttribute("y1", keyPos.y);
                line.setAttribute("x2", nodePos.x);
                line.setAttribute("y2", nodePos.y);
                line.setAttribute("stroke", node.color);
                line.setAttribute("stroke-width", "1");
                line.setAttribute("opacity", "0.6");
                svg.appendChild(line);
            });
        }

        function clearHighlights() {
            const svg = document.getElementById('interaction-svg');
            if (svg) svg.innerHTML = '';
        }

        function describeArcNoRotate(x, y, radius, startAngle, endAngle) {
             // Adjust angles because 0 is Top in our data, but 0 is Right in Math.
             // So Data 0 -> Math -90.
             return describeArc(x, y, radius, startAngle - 90, endAngle - 90);
        }

        // Add Arrow Marker definition to SVG once
        // We can do this in HTML or JS. Let's do it in JS init.
        function initMarkers() {
             const svg = document.getElementById('interaction-svg');
             if(!svg) return;
             
             // We need a defs block. Since we clear innerHTML, we should re-add it or put it in the static HTML.
             // Let's put it in static HTML via replace_string or just re-add it in highlightKey if missing.
             // Better: Add it to the main ring-svg which is not cleared? 
             // No, ring-svg is cleared in render().
             // Let's add it to interaction-svg in render() or just append it.
        }
        
        // Actually, let's just add the marker def to the HTML directly.


        function updateStats(movedCount) {
            // Count keys per real node
            const counts = {};
            const realNodes = [...new Set(nodes.map(n => n.parentId))];
            realNodes.forEach(id => counts[id] = 0);
            
            keys.forEach(k => {
                if (k.ownerId) counts[k.ownerId]++;
            });

            // Update Chart
            const chart = document.getElementById('load-chart');
            chart.innerHTML = '';
            
            let maxVal = 0;
            Object.values(counts).forEach(v => maxVal = Math.max(maxVal, v));
            
            realNodes.forEach(id => {
                const count = counts[id];
                const color = nodes.find(n => n.parentId === id).color;
                const percent = keys.length > 0 ? Math.round((count / keys.length) * 100) : 0;
                const width = keys.length > 0 ? (count / maxVal) * 100 : 0;

                const row = document.createElement('div');
                row.className = 'bar-row';
                row.innerHTML = `
                    <div class="bar-label">${id}</div>
                    <div class="bar-track">
                        <div class="bar-fill" style="width: ${width}%; background: ${color};">
                            ${count} (${percent}%)
                        </div>
                    </div>
                `;
                chart.appendChild(row);
            });

            // Calc Std Dev
            const values = Object.values(counts);
            const mean = values.reduce((a,b) => a+b, 0) / values.length || 0;
            const variance = values.reduce((a,b) => a + Math.pow(b - mean, 2), 0) / values.length || 0;
            const stdDev = Math.sqrt(variance).toFixed(2);

            document.getElementById('stat-nodes').innerText = realNodes.length;
            document.getElementById('stat-keys').innerText = keys.length;
            document.getElementById('stat-stddev').innerText = stdDev;
            document.getElementById('stat-migration').innerText = `${movedCount} keys`;
            
            // Color code std dev
            const stdEl = document.getElementById('stat-stddev');
            if (stdDev < 5) stdEl.style.color = 'green';
            else if (stdDev < 15) stdEl.style.color = 'orange';
            else stdEl.style.color = 'red';
        }

        function describeArcNoRotate(x, y, radius, startAngle, endAngle) {
             // Adjust angles because 0 is Top in our data, but 0 is Right in Math.
             // So Data 0 -> Math -90.
             return describeArc(x, y, radius, startAngle - 90, endAngle - 90);
        }

        // --- Helpers ---

        function getPos(angle, radius) {
            const rad = (angle - 90) * (Math.PI / 180);
            return {
                x: CENTER + radius * Math.cos(rad),
                y: CENTER + radius * Math.sin(rad)
            };
        }

        function describeArc(x, y, radius, startAngle, endAngle) {
            // Convert to radians
            // SVG coordinate system: 0 is right (3 o'clock), clockwise.
            // Our system: 0 is top (12 o'clock), clockwise.
            // Adjust: -90 degrees offset handled in CSS rotate, so here we treat 0 as 0.
            
            // Handle wrap-around for drawing
            if (startAngle > endAngle) startAngle -= 360;

            const start = polarToCartesian(x, y, radius, endAngle);
            const end = polarToCartesian(x, y, radius, startAngle);

            const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

            const d = [
                "M", start.x, start.y, 
                "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
            ].join(" ");

            return d;
        }

        function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
            var rad = angleInDegrees * Math.PI / 180.0;
            return {
                x: centerX + (radius * Math.cos(rad)),
                y: centerY + (radius * Math.sin(rad))
            };
        }

        function log(msg) {
            const div = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span style="color:#888">[${new Date().toLocaleTimeString().split(' ')[0]}]</span> ${msg}`;
            div.prepend(entry);
        }

        // --- Modal Logic ---
        function openHelp() {
            document.getElementById('helpModal').style.display = "block";
        }
        function closeHelp() {
            document.getElementById('helpModal').style.display = "none";
        }
        function openInterview() {
            document.getElementById('interviewModal').style.display = "block";
        }
        function closeInterview() {
            document.getElementById('interviewModal').style.display = "none";
        }
        // Close modal if user clicks outside
        window.onclick = function(event) {
            const helpModal = document.getElementById('helpModal');
            const interviewModal = document.getElementById('interviewModal');
            if (event.target == helpModal) {
                helpModal.style.display = "none";
            }
            if (event.target == interviewModal) {
                interviewModal.style.display = "none";
            }
        }

        // Init
        try {
            // Start with a clean state for better understanding
            // addNode();
            // addNode();
            // addNode();
            // addKeys(20);
            
            // Auto-open help on first load
            openHelp();
            
            // Add initial nodes after a slight delay so user sees the empty ring first? 
            // No, let's just init 3 nodes but maybe fewer keys.
            addNode();
            addNode();
            addNode();
            log("Tip: Click 'â“ ç®—æ³•è¯´æ˜' to understand the concept.");
        } catch (e) {
            alert("Initialization Error: " + e.message);
            console.error(e);
        }

    </script>
</body>
</html>