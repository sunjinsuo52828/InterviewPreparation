<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloom Filter Visualization</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1 { color: #673ab7; margin-bottom: 10px; }
        
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); width: 100%; max-width: 900px; position: relative; }
        
        .controls { display: flex; gap: 10px; margin-bottom: 20px; justify-content: center; flex-wrap: wrap; }
        input { padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 1rem; width: 200px; }
        button { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; transition: transform 0.1s; }
        button:active { transform: scale(0.95); }
        .btn-add { background: #28a745; color: white; }
        .btn-check { background: #007bff; color: white; }
        .btn-reset { background: #6c757d; color: white; }
        .btn-demo { background: #ff9800; color: white; }

        .bit-array-container { margin: 60px 0 40px 0; overflow-x: auto; padding-bottom: 10px; position: relative; }
        .bit-array { display: flex; gap: 4px; justify-content: center; min-width: max-content; }
        .bit { 
            width: 30px; height: 40px; border: 1px solid #ccc; border-radius: 4px; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 0.8rem; background: #f8f9fa; transition: all 0.3s; position: relative; z-index: 2;
        }
        .bit.active { background: #4caf50; color: white; border-color: #388e3c; font-weight: bold; }
        .bit-index { font-size: 0.6rem; color: #999; margin-top: 2px; }
        .bit-val { font-size: 1rem; }
        
        .bit.highlight { box-shadow: 0 0 15px #ff9800; border-color: #ff9800; transform: scale(1.2); z-index: 10; }
        .bit.check-pass { box-shadow: 0 0 15px #2196f3; border-color: #2196f3; }
        .bit.check-fail { box-shadow: 0 0 15px #f44336; border-color: #f44336; background: #ffebee; }

        .hash-functions { display: flex; justify-content: space-around; margin-bottom: 20px; position: relative; z-index: 2; }
        .hash-func { 
            background: #e3f2fd; padding: 15px; border-radius: 8px; border: 2px solid #90caf9; 
            width: 200px; text-align: center; position: relative; transition: all 0.3s;
        }
        .hash-func.active { background: #bbdefb; border-color: #1976d2; transform: scale(1.05); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .hash-val { font-size: 1.5rem; font-weight: bold; color: #1565c0; margin-top: 5px; min-height: 35px; }

        .log-area { 
            background: #212121; color: #00e676; padding: 15px; border-radius: 8px; 
            font-family: monospace; height: 150px; overflow-y: auto; margin-top: 20px; 
        }
        .log-entry { margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-entry.error { color: #ff5252; }
        .log-entry.warn { color: #ffab40; }
        .log-entry.info { color: #40c4ff; }

        .explanation {
            margin-top: 20px; padding: 15px; background: #fff3e0; border-left: 5px solid #ff9800; border-radius: 4px; color: #5d4037;
        }

        /* SVG Overlay for connecting lines */
        #svg-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;
        }
        path {
            fill: none; stroke: #ff9800; stroke-width: 3; stroke-dasharray: 10; animation: dash 1s linear infinite;
            opacity: 0; transition: opacity 0.3s;
        }
        path.visible { opacity: 1; }
        @keyframes dash { to { stroke-dashoffset: -20; } }

    </style>
</head>
<body>
    <h1>Bloom Filter Visualization</h1>
    
    <div class="container">
        <svg id="svg-overlay"></svg>

        <div class="explanation">
            <strong>How it works:</strong>
            <ol style="margin: 5px 0; padding-left: 20px;">
                <li><strong>Add:</strong> Run input through 3 hash functions. Each gives an index. Set those bits to 1.</li>
                <li><strong>Check:</strong> Run input through same hash functions. If <strong>ALL</strong> bits are 1, it's <em>Probably</em> there. If <strong>ANY</strong> bit is 0, it's <em>Definitely Not</em> there.</li>
            </ol>
        </div>

        <div class="controls">
            <input type="text" id="input-val" placeholder="Enter string (e.g. 'Apple')" onkeypress="if(event.key==='Enter') addVal()">
            <button class="btn-add" onclick="addVal()">Add to Set</button>
            <button class="btn-check" onclick="checkVal()">Check Existence</button>
            <button class="btn-demo" onclick="demoFalsePositive()">Demo False Positive</button>
            <button class="btn-reset" onclick="resetFilter()">Reset</button>
        </div>

        <div class="hash-functions">
            <div class="hash-func" id="h1-box">
                <div>Hash 1 (Mod 30)</div>
                <div class="hash-val" id="h1-val">-</div>
            </div>
            <div class="hash-func" id="h2-box">
                <div>Hash 2 (Mod 30)</div>
                <div class="hash-val" id="h2-val">-</div>
            </div>
            <div class="hash-func" id="h3-box">
                <div>Hash 3 (Mod 30)</div>
                <div class="hash-val" id="h3-val">-</div>
            </div>
        </div>

        <div class="bit-array-container">
            <div class="bit-array" id="bit-array">
                <!-- Bits generated by JS -->
            </div>
        </div>

        <div class="log-area" id="log">
            <div class="log-entry">> Ready. Array Size: 30 bits. 3 Hash Functions.</div>
        </div>
    </div>

    <script>
        const ARRAY_SIZE = 30;
        const bitArray = new Array(ARRAY_SIZE).fill(0);
        let isAnimating = false;
        
        // Initialize UI
        const bitContainer = document.getElementById('bit-array');
        for(let i=0; i<ARRAY_SIZE; i++) {
            const div = document.createElement('div');
            div.className = 'bit';
            div.id = `bit-${i}`;
            div.innerHTML = `<span class="bit-val">0</span><span class="bit-index">${i}</span>`;
            bitContainer.appendChild(div);
        }

        // Hash Functions
        function hash1(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (hash << 5) - hash + str.charCodeAt(i);
                hash |= 0; 
            }
            return Math.abs(hash) % ARRAY_SIZE;
        }

        function hash2(str) {
            let hash = 5381;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) + hash) + str.charCodeAt(i); 
            }
            return Math.abs(hash) % ARRAY_SIZE;
        }

        function hash3(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = (hash + str.charCodeAt(i) * (i + 1));
            }
            return Math.abs(hash) % ARRAY_SIZE;
        }

        async function addVal() {
            if(isAnimating) return;
            const input = document.getElementById('input-val');
            const val = input.value.trim();
            if(!val) return;

            isAnimating = true;
            log(`--------------------------------`);
            log(`Adding "${val}"...`, 'info');
            
            const h1 = hash1(val);
            const h2 = hash2(val);
            const h3 = hash3(val);

            await runHashAnimation(1, h1, 'set');
            await runHashAnimation(2, h2, 'set');
            await runHashAnimation(3, h3, 'set');

            log(`> SUCCESS: "${val}" added.`, 'info');
            input.value = '';
            isAnimating = false;
        }

        async function checkVal() {
            if(isAnimating) return;
            const input = document.getElementById('input-val');
            const val = input.value.trim();
            if(!val) return;

            isAnimating = true;
            log(`--------------------------------`);
            log(`Checking "${val}"...`, 'info');

            const h1 = hash1(val);
            const h2 = hash2(val);
            const h3 = hash3(val);

            // Check 1
            await runHashAnimation(1, h1, 'check');
            if(bitArray[h1] === 0) {
                log(`> Bit ${h1} is 0. STOP.`, 'error');
                log(`> Result: "${val}" is DEFINITELY NOT in set.`, 'error');
                isAnimating = false;
                return;
            }

            // Check 2
            await runHashAnimation(2, h2, 'check');
            if(bitArray[h2] === 0) {
                log(`> Bit ${h2} is 0. STOP.`, 'error');
                log(`> Result: "${val}" is DEFINITELY NOT in set.`, 'error');
                isAnimating = false;
                return;
            }

            // Check 3
            await runHashAnimation(3, h3, 'check');
            if(bitArray[h3] === 0) {
                log(`> Bit ${h3} is 0. STOP.`, 'error');
                log(`> Result: "${val}" is DEFINITELY NOT in set.`, 'error');
                isAnimating = false;
                return;
            }

            log(`> All bits [${h1}, ${h2}, ${h3}] are 1.`, 'warn');
            log(`> Result: "${val}" is POSSIBLY in set.`, 'warn');
            isAnimating = false;
        }

        async function demoFalsePositive() {
            if(isAnimating) return;
            resetFilter();
            
            // These values are chosen because they might collide on small array sizes or just to show the concept
            // Actually, finding a real collision on 3 hashes mod 30 is hard on the fly.
            // So we will simulate a scenario where bits are filled up.
            
            document.getElementById('input-val').value = "Apple";
            await addVal();
            
            document.getElementById('input-val').value = "Banana";
            await addVal();

            document.getElementById('input-val').value = "Cherry";
            await addVal();

            log(`> Now try checking a word you haven't added, like "Date" or "Elderberry".`, 'warn');
            log(`> If "Date" happens to map to bits that are already 1 (from Apple/Banana/Cherry), it's a False Positive!`, 'warn');
        }

        async function runHashAnimation(funcNum, index, mode) {
            const hashBox = document.getElementById(`h${funcNum}-box`);
            const hashVal = document.getElementById(`h${funcNum}-val`);
            const targetBit = document.getElementById(`bit-${index}`);

            // 1. Activate Hash Box
            hashBox.classList.add('active');
            hashVal.innerText = index;
            log(`> Hash ${funcNum} calculated index: ${index}`);
            await wait(500);

            // 2. Draw Line
            const line = drawLine(hashBox, targetBit);
            line.classList.add('visible');
            await wait(500);

            // 3. Interact with Bit
            if (mode === 'set') {
                bitArray[index] = 1;
                targetBit.classList.add('active');
                targetBit.querySelector('.bit-val').innerText = '1';
                targetBit.classList.add('highlight');
            } else {
                // Check mode
                if (bitArray[index] === 1) {
                    targetBit.classList.add('check-pass');
                    log(`  - Bit ${index} is 1 (Match)`);
                } else {
                    targetBit.classList.add('check-fail');
                    log(`  - Bit ${index} is 0 (Miss)`);
                }
            }
            
            await wait(600);

            // Cleanup
            hashBox.classList.remove('active');
            line.remove();
            targetBit.classList.remove('highlight', 'check-pass', 'check-fail');
        }

        function drawLine(startEl, endEl) {
            const svg = document.getElementById('svg-overlay');
            const startRect = startEl.getBoundingClientRect();
            const endRect = endEl.getBoundingClientRect();
            const containerRect = document.querySelector('.container').getBoundingClientRect();

            // Calculate relative coordinates
            const x1 = startRect.left + startRect.width / 2 - containerRect.left;
            const y1 = startRect.bottom - containerRect.top;
            const x2 = endRect.left + endRect.width / 2 - containerRect.left;
            const y2 = endRect.top - containerRect.top;

            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            // Bezier curve
            const d = `M ${x1} ${y1} C ${x1} ${y1+50}, ${x2} ${y2-50}, ${x2} ${y2}`;
            path.setAttribute("d", d);
            svg.appendChild(path);
            return path;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function log(msg, type='') {
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.innerText = msg;
            const container = document.getElementById('log');
            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function resetFilter() {
            bitArray.fill(0);
            document.querySelectorAll('.bit').forEach(b => {
                b.classList.remove('active');
                b.querySelector('.bit-val').innerText = '0';
            });
            document.getElementById('h1-val').innerText = '-';
            document.getElementById('h2-val').innerText = '-';
            document.getElementById('h3-val').innerText = '-';
            document.getElementById('log').innerHTML = '<div class="log-entry">> Reset complete.</div>';
            isAnimating = false;
        }
    </script>
</body>
</html>
