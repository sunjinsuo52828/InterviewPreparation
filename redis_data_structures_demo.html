<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Data Structures Visualization</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1 { color: #d82c20; margin-bottom: 10px; }
        
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .tab { padding: 10px 20px; background: #ddd; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .tab.active { background: #d82c20; color: white; transform: scale(1.05); }
        
        .container { width: 100%; max-width: 1000px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); min-height: 500px; position: relative; }
        .controls { margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 5px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { background: #333; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        button:hover { background: #555; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 80px; }

        .narrative {
            background: #e1f5fe; color: #01579b; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 1.1rem; line-height: 1.6; min-height: 60px; display: flex; align-items: center; border-left: 5px solid #0288d1;
        }

        /* SkipList Styles */
        .skiplist-container { position: relative; padding-top: 20px; overflow-x: auto; }
        .skiplist-level { display: flex; align-items: center; margin-bottom: 15px; position: relative; height: 50px; }
        .level-label { width: 80px; font-weight: bold; color: #666; flex-shrink: 0; }
        
        .sl-node { 
            width: 40px; height: 40px; border: 2px solid #333; background: white; 
            display: flex; align-items: center; justify-content: center; 
            border-radius: 50%; font-weight: bold; z-index: 2;
            position: absolute; transition: all 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .sl-node.head { background: #eee; border-color: #999; }
        .sl-node.highlight { background: #ffeb3b; border-color: #fbc02d; transform: scale(1.2); z-index: 10; }
        .sl-node.visited { background: #e0f7fa; border-color: #00bcd4; }
        .sl-node.target { background: #4caf50; color: white; border-color: #2e7d32; }

        .sl-line { position: absolute; height: 2px; background: #e0e0e0; top: 25px; left: 80px; width: 100%; z-index: 1; }
        
        /* Arrow for search path */
        .search-arrow {
            position: absolute; height: 3px; background: #d82c20; z-index: 5; transform-origin: 0 50%;
            transition: width 0.3s linear;
        }

        /* LRU Styles */
        .lru-wrapper { display: flex; flex-direction: column; align-items: center; margin-top: 30px; }
        .cache-box { 
            display: flex; gap: 15px; padding: 20px; border: 3px dashed #ccc; border-radius: 15px; 
            min-height: 100px; width: 90%; align-items: center; overflow-x: auto; background: #fafafa;
        }
        .lru-item {
            min-width: 70px; height: 70px; background: #fff; border: 2px solid #0288d1; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); position: relative;
            transition: all 0.4s ease;
        }
        .lru-item span { font-size: 1.2rem; }
        .lru-item .tag { font-size: 0.7rem; color: #666; margin-top: 4px; font-weight: normal; }
        
        .lru-item.new { animation: popIn 0.5s; background: #e8f5e9; border-color: #4caf50; }
        .lru-item.hit { animation: flashGreen 1s; background: #e8f5e9; border-color: #4caf50; }
        .lru-item.evict { animation: fadeOut 0.5s forwards; background: #ffebee; border-color: #f44336; }

        @keyframes popIn { 0% { transform: scale(0); } 80% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes flashGreen { 0% { background: #fff; } 50% { background: #b9f6ca; transform: scale(1.1); } 100% { background: #fff; } }
        @keyframes fadeOut { to { opacity: 0; transform: translateY(20px); } }

        /* Log Console */
        .log-console {
            background: #212121; color: #00e676; padding: 15px; border-radius: 8px; 
            font-family: 'Consolas', monospace; height: 150px; overflow-y: auto; margin-top: 20px;
            font-size: 0.9rem; border: 1px solid #444;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-time { color: #888; margin-right: 10px; font-size: 0.8rem; }
        .log-info { color: #4fc3f7; }
        .log-warn { color: #ffb74d; }
        .log-error { color: #ef5350; }

        /* Theory Section */
        .theory-section { display: none; padding: 20px; }
        .theory-card { background: #f8f9fa; border-left: 4px solid #d82c20; padding: 15px; margin-bottom: 15px; border-radius: 4px; }
        .theory-card h3 { margin-top: 0; color: #333; }
        .theory-card ul { margin-bottom: 0; padding-left: 20px; }
        .theory-card li { margin-bottom: 5px; }

    </style>
</head>
<body>
    <h1>Redis Data Structures & Architecture</h1>
    <div class="tabs">
        <div class="tab active" onclick="switchTab('skiplist')">SkipList (ZSet)</div>
        <div class="tab" onclick="switchTab('lru')">LRU Cache</div>
        <div class="tab" onclick="switchTab('theory')">Why Redis is Fast?</div>
    </div>

    <div class="container">
        <div class="narrative" id="narrative">
            Select a tab to begin. SkipList is used for Sorted Sets (ZSet). LRU is used for memory eviction.
        </div>

        <!-- Theory View -->
        <div id="theory-view" class="theory-section">
            <div class="theory-card">
                <h3>üöÄ Why is Redis so Fast? (100k+ QPS)</h3>
                <ul>
                    <li><strong>In-Memory Storage:</strong> Accessing RAM (ns) is 100,000x faster than Disk (ms).</li>
                    <li><strong>Single-Threaded Model:</strong> Avoids Context Switching and Lock Contention (Race Conditions).</li>
                    <li><strong>IO Multiplexing (epoll):</strong> Handles thousands of connections using a single thread efficiently.</li>
                    <li><strong>Efficient Data Structures:</strong> SDS (Simple Dynamic String), SkipList, ZipList are optimized for speed.</li>
                </ul>
            </div>

            <div class="theory-card" style="border-left-color: #0288d1;">
                <h3>üõ°Ô∏è High Availability (Sentinel)</h3>
                <ul>
                    <li><strong>Monitoring:</strong> Sentinel nodes check if Master is alive.</li>
                    <li><strong>Automatic Failover:</strong> If Master dies, Sentinel promotes a Slave to be the new Master.</li>
                    <li><strong>Notification:</strong> Clients are notified of the new Master address.</li>
                </ul>
            </div>

            <div class="theory-card" style="border-left-color: #ff9800;">
                <h3>üåê Scalability (Cluster)</h3>
                <ul>
                    <li><strong>Sharding:</strong> Data is split into 16,384 Hash Slots.</li>
                    <li><strong>Distribution:</strong> Different nodes hold different slots (e.g., Node A: 0-5000, Node B: 5001-10000).</li>
                    <li><strong>Decentralized:</strong> No central proxy; clients can connect to any node to find the right slot.</li>
                </ul>
            </div>
        </div>

        <!-- SkipList View -->
        <div id="skiplist-view">
            <div class="controls">
                <input type="number" id="slInput" placeholder="Value" value="15">
                <button onclick="slInsert()" id="btn-insert">Insert</button>
                <button onclick="slSearch()" id="btn-search" style="background: #0078d4;">Search</button>
                <button onclick="slReset()" style="background: #757575;">Reset</button>
            </div>
            
            <!-- Deep Dive Info Panel -->
            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 5px solid #ff9800;">
                <h3 style="margin-top:0; color:#e65100;">ü§î Deep Dive: Why SkipList?</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <strong>1. Why SkipList instead of Red-Black Tree?</strong>
                        <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                            <li><strong>Simplicity:</strong> Much easier to implement and debug than balanced trees.</li>
                            <li><strong>Range Queries:</strong> Finding a range (e.g., `ZRANGE`) is faster. Just find the start node and traverse Level 0 forward. Trees require complex traversal.</li>
                            <li><strong>Memory:</strong> SkipList nodes average 1.33 pointers per node, while Trees always need 2 (Left/Right) + Color bit.</li>
                        </ul>
                    </div>
                    <div>
                        <strong>2. How is Level Calculated? (Probabilistic)</strong>
                        <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                            <li>It uses a "Coin Flip" strategy (Geometric Distribution).</li>
                            <li>Level 1: 100%</li>
                            <li>Level 2: 50% (1/2 chance)</li>
                            <li>Level 3: 25% (1/4 chance)</li>
                            <li>Redis uses `p=0.25` (1/4) for better memory efficiency. Max Level is 32.</li>
                        </ul>
                    </div>
                    <div>
                        <strong>3. How Search Works?</strong>
                        <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                            <li>Start at the <strong>Top Level</strong> Head.</li>
                            <li>Move <strong>Right</strong> if `next.val < target`.</li>
                            <li>Move <strong>Down</strong> if `next.val >= target` (or next is null).</li>
                            <li>Repeat until Level 0. Complexity: $O(\log N)$.</li>
                        </ul>
                    </div>
                    <div>
                        <strong>4. Expiration & Updates?</strong>
                        <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                            <li><strong>Expiration:</strong> ZSet elements <em>do not</em> expire individually. Only the entire Key (ZSet) has a TTL.</li>
                            <li><strong>Updates:</strong> If you update a Score (`ZADD`), Redis deletes the old node and re-inserts it with the new score (and potentially a new random level).</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div id="sl-canvas" class="skiplist-container" style="height: 350px;"></div>
        </div>

        <!-- LRU View -->
        <div id="lru-view" style="display: none;">
            <div class="controls">
                <input type="text" id="lruInput" placeholder="Key (e.g. A)" maxlength="2">
                <button onclick="lruAccess()" style="background: #0078d4;">Get / Put</button>
                <span style="margin-left: auto; font-weight: bold; color: #666;">Capacity: 5</span>
            </div>
            <div class="lru-wrapper">
                <div style="width: 90%; display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; color: #555;">
                    <span>MRU (Most Recently Used) <br><small style="font-weight:normal; color:#888">Front of Queue</small></span>
                    <span style="text-align: right;">LRU (Least Recently Used) <br><small style="font-weight:normal; color:#888">Back of Queue</small></span>
                </div>
                <div class="cache-box" id="lru-box"></div>
            </div>
        </div>

        <!-- Log Console -->
        <div class="log-console" id="log-console">
            <div class="log-entry">> Redis Server Ready. Waiting for commands...</div>
        </div>
    </div>

    <script>
        let currentTab = 'skiplist';
        let isAnimating = false;

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
            
            document.getElementById('skiplist-view').style.display = tab === 'skiplist' ? 'block' : 'none';
            document.getElementById('lru-view').style.display = tab === 'lru' ? 'block' : 'none';
            document.getElementById('theory-view').style.display = tab === 'theory' ? 'block' : 'none';
            
            if(tab === 'skiplist') {
                narrate("<strong>SkipList (ZSet)</strong>: A multi-level linked list. Higher levels allow 'skipping' over many nodes to find values faster ($O(\\log N)$).");
                log("Switched to SkipList view.");
            } else if(tab === 'lru') {
                narrate("<strong>LRU Cache</strong>: Keeps recently used items at the front. When full, the item at the back (Least Recently Used) is removed.");
                log("Switched to LRU Cache view.");
            } else {
                narrate("<strong>Theory</strong>: Understanding Redis Architecture (Speed, HA, Scalability).");
                log("Viewing Redis Architecture Theory.");
            }
        }

        function narrate(html) {
            document.getElementById('narrative').innerHTML = html;
        }

        function log(msg, type='info') {
            const consoleDiv = document.getElementById('log-console');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;
            
            consoleDiv.appendChild(entry);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

        // --- SkipList Logic ---
        const MAX_LEVEL = 4;
        class SLNode {
            constructor(val, level) {
                this.val = val;
                this.forward = new Array(level + 1).fill(null);
                this.level = level;
            }
        }

        let head = new SLNode(-Infinity, MAX_LEVEL);
        let slNodes = []; 

        function randomLevel() {
            let lvl = 0;
            // Redis uses p=0.25, but for this small demo we use p=0.5 to show more levels
            let logStr = "Dice Rolls: ";
            while (Math.random() < 0.5 && lvl < MAX_LEVEL) {
                lvl++;
                logStr += "Heads (Up) -> ";
            }
            logStr += "Tails (Stop). Final Level: " + lvl;
            log(logStr, 'info');
            return lvl;
        }

        function slInsert() {
            if(isAnimating) return;
            const val = parseInt(document.getElementById('slInput').value);
            if (isNaN(val)) return;
            
            if (slNodes.find(n => n.val === val)) {
                narrate(`Value <strong>${val}</strong> already exists.`);
                log(`Insert failed: Value ${val} already exists.`, 'warn');
                return;
            }

            log(`CMD: ZADD myzset ${val}`);
            narrate(`Inserting <strong>${val}</strong>... Calculating random level.`);

            const update = new Array(MAX_LEVEL + 1).fill(null);
            let current = head;

            for (let i = MAX_LEVEL; i >= 0; i--) {
                while (current.forward[i] && current.forward[i].val < val) {
                    current = current.forward[i];
                }
                update[i] = current;
            }

            const lvl = randomLevel();
            log(`Generated Random Level: ${lvl}`);
            const newNode = new SLNode(val, lvl);
            
            for (let i = 0; i <= lvl; i++) {
                newNode.forward[i] = update[i].forward[i];
                update[i].forward[i] = newNode;
            }
            
            slNodes.push(newNode);
            slNodes.sort((a, b) => a.val - b.val);
            renderSkipList();
            narrate(`Inserted <strong>${val}</strong> at Level ${lvl}. Notice how it appears on multiple levels.`);
            log(`Successfully inserted ${val} at Level ${lvl}.`, 'info');
        }

        async function slSearch() {
            if(isAnimating) return;
            const val = parseInt(document.getElementById('slInput').value);
            if (isNaN(val)) return;

            isAnimating = true;
            renderSkipList(); // Clear previous highlights
            log(`CMD: ZSCORE myzset ${val}`);
            narrate(`Searching for <strong>${val}</strong>. Starting from Top Level (L${MAX_LEVEL})...`);
            
            let current = head;
            let found = false;

            // Highlight Head
            highlightNode(current, 'visited');
            await wait(500);

            for (let i = MAX_LEVEL; i >= 0; i--) {
                narrate(`Checking <strong>Level ${i}</strong>...`);
                log(`Scanning Level ${i}...`);
                
                // Move right
                while (current.forward[i] && current.forward[i].val <= val) {
                    let nextNode = current.forward[i];
                    
                    // Visualize "Looking at next"
                    highlightNode(nextNode, 'highlight');
                    log(`  -> Comparing with node [${nextNode.val}]`);
                    await wait(600);

                    if (nextNode.val === val) {
                        narrate(`Found <strong>${val}</strong> at Level ${i}!`);
                        log(`  -> MATCH! Found ${val} at Level ${i}.`, 'info');
                        highlightNode(nextNode, 'target');
                        found = true;
                        isAnimating = false;
                        return;
                    }

                    if (nextNode.val < val) {
                        narrate(`<strong>${nextNode.val}</strong> < ${val}. Moving Right.`);
                        log(`  -> ${nextNode.val} < ${val}. Moving RIGHT.`);
                        current = nextNode;
                        highlightNode(current, 'visited');
                    }
                }

                if (i > 0) {
                    narrate(`Next value is too big (or null). Dropping down to <strong>Level ${i-1}</strong>.`);
                    log(`  -> Next node is too large. Dropping DOWN to Level ${i-1}.`);
                    await wait(600);
                }
            }

            narrate(`Reached bottom level. Value <strong>${val}</strong> not found.`);
            log(`Search complete. Value ${val} NOT FOUND.`, 'error');
            isAnimating = false;
        }

        function highlightNode(node, className) {
            // A node exists visually at multiple levels. Highlight all of them or just the specific one?
            // For simplicity, let's highlight all visual instances of this node value.
            const val = node.val === -Infinity ? 'H' : node.val;
            document.querySelectorAll(`.sl-node[data-val="${val}"]`).forEach(el => {
                el.classList.add(className);
            });
        }

        function slReset() {
            head = new SLNode(-Infinity, MAX_LEVEL);
            slNodes = [];
            renderSkipList();
            narrate("SkipList reset.");
            log("SkipList cleared.");
        }

        function renderSkipList() {
            const container = document.getElementById('sl-canvas');
            container.innerHTML = '';

            const xStep = 70;
            const startX = 100;

            for (let i = MAX_LEVEL; i >= 0; i--) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'skiplist-level';
                levelDiv.style.top = (MAX_LEVEL - i) * 10 + 'px'; // Slight overlap or spacing
                
                const label = document.createElement('div');
                label.className = 'level-label';
                label.innerText = `Level ${i}`;
                levelDiv.appendChild(label);

                const line = document.createElement('div');
                line.className = 'sl-line';
                levelDiv.appendChild(line);

                // Draw Head
                const headNode = createVisualNode('H', 80, i);
                levelDiv.appendChild(headNode);

                // Draw nodes
                let current = head.forward[i];
                while(current) {
                    const idx = slNodes.indexOf(current);
                    const x = startX + (idx + 1) * xStep;
                    const nodeDiv = createVisualNode(current.val, x, i);
                    levelDiv.appendChild(nodeDiv);
                    current = current.forward[i];
                }

                container.appendChild(levelDiv);
            }
        }

        function createVisualNode(val, left, level) {
            const div = document.createElement('div');
            div.className = 'sl-node';
            if(val === 'H') div.classList.add('head');
            div.innerText = val;
            div.style.left = left + 'px';
            div.dataset.val = val;
            div.dataset.level = level;
            return div;
        }

        // --- LRU Logic ---
        const lruCapacity = 5;
        let lruCache = []; 

        async function lruAccess() {
            if(isAnimating) return;
            const input = document.getElementById('lruInput');
            const key = input.value.trim().toUpperCase();
            if (!key) return;
            input.value = '';

            isAnimating = true;
            const idx = lruCache.indexOf(key);
            log(`CMD: GET ${key}`);

            if (idx > -1) {
                // HIT
                narrate(`<strong>HIT!</strong> Key "${key}" found. Moving to MRU (Front).`);
                log(`Cache HIT for key "${key}". Moving to Head (MRU).`, 'info');
                
                // Visual: Highlight existing
                const items = document.querySelectorAll('.lru-item');
                items[idx].classList.add('hit');
                await wait(800);

                lruCache.splice(idx, 1);
                lruCache.unshift(key);
            } else {
                // MISS
                if (lruCache.length >= lruCapacity) {
                    const evicted = lruCache[lruCache.length - 1];
                    narrate(`<strong>MISS!</strong> Cache full. Evicting LRU "${evicted}" and adding "${key}".`);
                    log(`Cache MISS. Capacity Full. Evicting "${evicted}" (LRU).`, 'warn');
                    
                    // Visual: Evict animation
                    const items = document.querySelectorAll('.lru-item');
                    items[items.length - 1].classList.add('evict');
                    await wait(600);
                    
                    lruCache.pop();
                } else {
                    narrate(`<strong>MISS!</strong> Adding "${key}" to cache.`);
                    log(`Cache MISS. Adding "${key}" to Head.`, 'info');
                }
                lruCache.unshift(key);
            }
            
            renderLRU();
            // Add 'new' class to first element for animation
            setTimeout(() => {
                const first = document.querySelector('.lru-item');
                if(first) first.classList.add('new');
            }, 50);
            
            isAnimating = false;
        }

        function renderLRU() {
            const box = document.getElementById('lru-box');
            box.innerHTML = '';
            
            lruCache.forEach((key, index) => {
                const div = document.createElement('div');
                div.className = 'lru-item';
                div.innerHTML = `<span>${key}</span><span class="tag">${index===0 ? 'MRU' : (index===lruCache.length-1 ? 'LRU' : '')}</span>`;
                box.appendChild(div);
            });
        }

        // Init
        slReset();
        [3, 7, 12, 19, 25].forEach(v => {
            document.getElementById('slInput').value = v;
            slInsert();
        });
        document.getElementById('slInput').value = "";
        narrate("<strong>SkipList (ZSet)</strong>: Initialized with some data. Try searching for 19.");

        lruCache = ['C', 'B', 'A'];
        renderLRU();

    </script>
</body>
</html>