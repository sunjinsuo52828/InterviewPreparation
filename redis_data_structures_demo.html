<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Data Structures & Architecture Visualization</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1 { color: #d82c20; margin-bottom: 10px; }
        
        .tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        .tab { padding: 10px 20px; background: #ddd; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .tab.active { background: #d82c20; color: white; transform: scale(1.05); }
        
        .container { width: 100%; max-width: 1000px; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); min-height: 500px; position: relative; }
        .controls { margin-bottom: 20px; padding: 15px; background: #f9f9f9; border-radius: 5px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { background: #333; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; font-weight: bold; }
        button:hover { background: #555; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input { padding: 8px; border: 1px solid #ccc; border-radius: 4px; width: 80px; }

        .narrative {
            background: #e1f5fe; color: #01579b; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-size: 1.1rem; line-height: 1.6; min-height: 60px; display: flex; align-items: center; border-left: 5px solid #0288d1;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5);
            display: none; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background: white; width: 800px; max-height: 90vh; overflow-y: auto; padding: 30px; border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2); position: relative;
        }
        .close-btn {
            position: absolute; top: 15px; right: 20px; font-size: 1.5rem; cursor: pointer; color: #666;
        }
        .close-btn:hover { color: #d82c20; }

        /* SkipList Styles */
        .skiplist-container { position: relative; padding-top: 20px; overflow-x: auto; }
        .skiplist-level { display: flex; align-items: center; margin-bottom: 15px; position: relative; height: 50px; }
        .level-label { width: 80px; font-weight: bold; color: #666; flex-shrink: 0; }
        
        .sl-node { 
            width: 40px; height: 40px; border: 2px solid #333; background: white; 
            display: flex; align-items: center; justify-content: center; 
            border-radius: 50%; font-weight: bold; z-index: 2;
            position: absolute; transition: all 0.3s; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .sl-node.head { background: #eee; border-color: #999; }
        .sl-node.highlight { background: #ffeb3b; border-color: #fbc02d; transform: scale(1.2); z-index: 10; }
        .sl-node.visited { background: #e0f7fa; border-color: #00bcd4; }
        .sl-node.target { background: #4caf50; color: white; border-color: #2e7d32; }

        .sl-line { position: absolute; height: 2px; background: #e0e0e0; top: 25px; left: 80px; width: 100%; z-index: 1; }
        
        /* Arrow for search path */
        .search-arrow {
            position: absolute; height: 3px; background: #d82c20; z-index: 5; transform-origin: 0 50%;
            transition: width 0.3s linear;
        }

        /* LRU Styles */
        .lru-wrapper { display: flex; flex-direction: column; align-items: center; margin-top: 30px; }
        .cache-box { 
            display: flex; gap: 15px; padding: 20px; border: 3px dashed #ccc; border-radius: 15px; 
            min-height: 100px; width: 90%; align-items: center; overflow-x: auto; background: #fafafa;
        }
        .lru-item {
            min-width: 70px; height: 70px; background: #fff; border: 2px solid #0288d1; border-radius: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05); position: relative;
            transition: all 0.4s ease;
        }
        .lru-item span { font-size: 1.2rem; }
        .lru-item .tag { font-size: 0.7rem; color: #666; margin-top: 4px; font-weight: normal; }
        
        .lru-item.new { animation: popIn 0.5s; background: #e8f5e9; border-color: #4caf50; }
        .lru-item.hit { animation: flashGreen 1s; background: #e8f5e9; border-color: #4caf50; }
        .lru-item.evict { animation: fadeOut 0.5s forwards; background: #ffebee; border-color: #f44336; }

        @keyframes popIn { 0% { transform: scale(0); } 80% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes flashGreen { 0% { background: #fff; } 50% { background: #b9f6ca; transform: scale(1.1); } 100% { background: #fff; } }
        @keyframes fadeOut { to { opacity: 0; transform: translateY(20px); } }

        /* Log Console */
        .log-console {
            background: #212121; color: #00e676; padding: 15px; border-radius: 8px; 
            font-family: 'Consolas', monospace; height: 150px; overflow-y: auto; margin-top: 20px;
            font-size: 0.9rem; border: 1px solid #444;
        }
        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-time { color: #888; margin-right: 10px; font-size: 0.8rem; }
        .log-info { color: #4fc3f7; }
        .log-warn { color: #ffb74d; }
        .log-error { color: #ef5350; }

        /* Theory Section */
        .theory-section { display: none; padding: 20px; }
        .theory-card { background: #f8f9fa; border-left: 4px solid #d82c20; padding: 15px; margin-bottom: 15px; border-radius: 4px; }
        .theory-card h3 { margin-top: 0; color: #333; }
        .theory-card ul { margin-bottom: 0; padding-left: 20px; }
        .theory-card li { margin-bottom: 5px; }

    </style>
</head>
<body>
    <h1>Redis Data Structures & Architecture Visualization</h1>
    <div class="tabs">
        <div class="tab active" onclick="switchTab('skiplist')">SkipList (ZSet)</div>
        <div class="tab" onclick="switchTab('lru')">LRU Eviction</div>
        <div class="tab" onclick="switchTab('theory')">Why Redis is Fast?</div>
    </div>

    <!-- Modal Overlay -->
    <div id="deep-dive-modal" class="modal-overlay" onclick="closeModal(event)">
        <div class="modal-content">
            <span class="close-btn" onclick="document.getElementById('deep-dive-modal').style.display='none'">&times;</span>
            <h2 style="color:#e65100; margin-top:0;">ü§î Deep Dive: Why SkipList?</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <strong>1. Why not Red-Black Tree?</strong>
                    <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                        <li><strong>Simplicity:</strong> SkipLists are easier to implement and debug than balanced trees.</li>
                        <li><strong>Range Queries:</strong> ZSet often needs range scans (`ZRANGE`). SkipList just finds the start node and traverses the Level 0 list. Trees require complex traversal.</li>
                        <li><strong>Memory:</strong> SkipList nodes average 1.33 pointers, while tree nodes usually need 2 (left/right) + color bit.</li>
                    </ul>
                </div>
                <div>
                    <strong>2. How are levels decided? (Probabilistic)</strong>
                    <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                        <li>Uses a "Coin Flip" strategy (Geometric Distribution).</li>
                        <li><strong>Algorithm:</strong> Start at Level 1. Flip coin (p=0.25). If heads, Level++. Repeat until tails or max level (32).</li>
                        <li>Level 1: 100% (All nodes)</li>
                        <li>Level 2: 25% (1/4 probability)</li>
                        <li>Level 3: 6.25% (1/16 probability)</li>
                        <li>This creates a pyramid structure where higher levels are sparse.</li>
                    </ul>
                </div>
                <div>
                    <strong>3. Search Process</strong>
                    <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                        <li>Start at Head of <strong>Highest Level</strong>.</li>
                        <li>If `next.val < target`, move <strong>RIGHT</strong>.</li>
                        <li>If `next.val >= target` (or next is null), move <strong>DOWN</strong>.</li>
                        <li>Repeat until Level 0. Time Complexity: $O(\log N)$.</li>
                    </ul>
                </div>
                <div>
                    <strong>4. Expiration & Updates</strong>
                    <ul style="margin-top:5px; padding-left:20px; font-size:0.9rem; color:#333;">
                        <li><strong>Expiration:</strong> Elements in ZSet do <em>not</em> expire individually. Only the whole Key (ZSet) has a TTL.</li>
                        <li><strong>Update:</strong> If Score is updated (`ZADD`), Redis deletes the old node and re-inserts with new Score (potentially new random level).</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="narrative" id="narrative">
            Select a tab to begin. SkipList is used for Sorted Sets (ZSet), LRU for memory eviction.
        </div>

        <!-- Theory View -->
        <div id="theory-view" class="theory-section">
            <div class="theory-card">
                <h3>üöÄ Why is Redis so Fast? (100k+ QPS)</h3>
                <ul>
                    <li><strong>In-Memory:</strong> Accessing RAM (nanoseconds) is 100,000x faster than Disk (milliseconds).</li>
                    <li><strong>Single-Threaded Model:</strong> Avoids Context Switching and Lock Contention overhead.</li>
                    <li><strong>IO Multiplexing (epoll):</strong> Efficiently handles thousands of concurrent connections using a single thread.</li>
                    <li><strong>Efficient Data Structures:</strong> SDS (Simple Dynamic String), SkipList, ZipList are highly optimized.</li>
                </ul>
            </div>

            <div class="theory-card" style="border-left-color: #0288d1;">
                <h3>üõ°Ô∏è High Availability (Sentinel)</h3>
                <ul>
                    <li><strong>Monitoring:</strong> Sentinels constantly check if Master is alive.</li>
                    <li><strong>Automatic Failover:</strong> If Master dies, Sentinel promotes a Slave to be the new Master.</li>
                    <li><strong>Notification:</strong> Clients are notified of the new Master address.</li>
                </ul>
            </div>

            <div class="theory-card" style="border-left-color: #ff9800;">
                <h3>üåê Scalability (Cluster)</h3>
                <ul>
                    <li><strong>Sharding:</strong> Data is split into 16,384 Hash Slots.</li>
                    <li><strong>Distribution:</strong> Different nodes hold different slot ranges (e.g., Node A: 0-5000).</li>
                    <li><strong>Decentralized:</strong> No central proxy. Clients can connect to any node, which redirects (MOVED) to the correct one.</li>
                </ul>
            </div>
        </div>

        <!-- SkipList View -->
        <div id="skiplist-view">
            <div class="controls">
                <input type="number" id="slInput" placeholder="Value" value="15">
                <button onclick="slInsert()" id="btn-insert">Insert</button>
                <button onclick="slSearch()" id="btn-search" style="background: #0078d4;">Search</button>
                <button onclick="slReset()" style="background: #757575;">Reset</button>
                <button onclick="openModal()" style="background: #e65100; margin-left: auto;">ü§î Deep Dive: Why SkipList?</button>
            </div>
            
            <div id="sl-canvas" class="skiplist-container" style="height: 350px;"></div>
        </div>

        <!-- LRU View -->
        <div id="lru-view" style="display: none;">
            <div class="controls">
                <input type="text" id="lruInput" placeholder="Key (e.g. A)" maxlength="2">
                <button onclick="lruAccess()" style="background: #0078d4;">Get / Put</button>
                <span style="margin-left: auto; font-weight: bold; color: #666;">Capacity: 5</span>
            </div>
            <div class="lru-wrapper">
                <div style="width: 90%; display: flex; justify-content: space-between; margin-bottom: 10px; font-weight: bold; color: #555;">
                    <span>MRU (Most Recently Used) <br><small style="font-weight:normal; color:#888">Head of Queue</small></span>
                    <span style="text-align: right;">LRU (Least Recently Used) <br><small style="font-weight:normal; color:#888">Tail of Queue</small></span>
                </div>
                <div class="cache-box" id="lru-box"></div>
            </div>
        </div>

        <!-- Log Console -->
        <div class="log-console" id="log-console">
            <div class="log-entry">> Redis Server Ready. Waiting for commands...</div>
        </div>
    </div>

    <script>
        let currentTab = 'skiplist';
        let isAnimating = false;

        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
            
            document.getElementById('skiplist-view').style.display = tab === 'skiplist' ? 'block' : 'none';
            document.getElementById('lru-view').style.display = tab === 'lru' ? 'block' : 'none';
            document.getElementById('theory-view').style.display = tab === 'theory' ? 'block' : 'none';
            
            if(tab === 'skiplist') {
                narrate("<strong>SkipList</strong>: A multi-level linked list. Upper levels allow 'skipping' many nodes for fast search ($O(\\log N)$).");
                log("Switched to SkipList view.");
            } else if(tab === 'lru') {
                narrate("<strong>LRU Cache</strong>: Moves recently used items to the front. Removes the last item (Least Recently Used) when full.");
                log("Switched to LRU Cache view.");
            } else {
                narrate("<strong>Architecture Theory</strong>: Understanding Redis High Performance, HA, and Scalability.");
                log("Viewing Redis Architecture Theory.");
            }
        }

        function narrate(html) {
            document.getElementById('narrative').innerHTML = html;
        }

        function log(msg, type='info') {
            const consoleDiv = document.getElementById('log-console');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;
            
            consoleDiv.appendChild(entry);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

        // --- SkipList Logic ---
        const MAX_LEVEL = 4;
        class SLNode {
            constructor(val, level) {
                this.val = val;
                this.forward = new Array(level + 1).fill(null);
                this.level = level;
            }
        }

        let head = new SLNode(-Infinity, MAX_LEVEL);
        let slNodes = []; 

        function openModal() {
            document.getElementById('deep-dive-modal').style.display = 'flex';
        }

        function closeModal(e) {
            if (e.target.className === 'modal-overlay') {
                document.getElementById('deep-dive-modal').style.display = 'none';
            }
        }

        function randomLevel() {
            let lvl = 0;
            while (Math.random() < 0.25 && lvl < MAX_LEVEL - 1) {
                lvl++;
            }
            return lvl;
        }

        function slReset() {
            head = new SLNode(-Infinity, MAX_LEVEL);
            slNodes = [];
            renderSkipList();
            log("SkipList Reset.");
        }

        function slInsert() {
            const val = parseInt(document.getElementById('slInput').value);
            if (isNaN(val)) return;
            
            // Check duplicate
            if (slNodes.find(n => n.val === val)) {
                log(`Value ${val} already exists!`, 'warn');
                return;
            }

            const level = randomLevel();
            const newNode = new SLNode(val, level);
            slNodes.push(newNode);
            slNodes.sort((a, b) => a.val - b.val); // Keep sorted for rendering simplicity

            // Rebuild links (Simplified for visualization)
            log(`Inserted ${val} (Level: ${level + 1})`);
            renderSkipList();
        }

        async function slSearch() {
            if (isAnimating) return;
            const target = parseInt(document.getElementById('slInput').value);
            if (isNaN(target)) return;

            isAnimating = true;
            log(`Searching for: ${target}...`);
            
            // We need to simulate the path
            // Find the node in our simplified array
            const targetNode = slNodes.find(n => n.val === target);
            
            // Visualize path
            // Start at Head, Max Level
            let currentVal = -Infinity;
            let currentLevel = MAX_LEVEL - 1;
            
            // Clear highlights
            document.querySelectorAll('.sl-node').forEach(n => n.classList.remove('highlight', 'visited'));

            // Animation Loop
            // This is a "fake" traversal for visual effect based on the sorted array
            // Real traversal logic:
            let curr = head;
            
            // Let's just highlight the nodes we "visit"
            // 1. Highlight Head
            highlightNode(-Infinity, MAX_LEVEL - 1);
            await wait(500);

            for (let i = MAX_LEVEL - 1; i >= 0; i--) {
                // Move right in current level
                while (true) {
                    // Find next node in this level
                    // In our simplified array 'slNodes', find first node > curr.val
                    let nextNode = null;
                    for(let n of slNodes) {
                        if(n.val > (curr.val === -Infinity ? -999999 : curr.val)) {
                            // Check if this node has this level
                            if(n.level >= i) {
                                nextNode = n;
                                break;
                            }
                        }
                    }

                    if (nextNode && nextNode.val <= target) {
                        // Move Right
                        highlightNode(nextNode.val, i);
                        curr = nextNode;
                        await wait(500);
                        if (curr.val === target) {
                            log(`Found target ${target}!`, 'info');
                            document.querySelector(`.sl-node[data-val="${target}"]`).classList.add('target');
                            isAnimating = false;
                            return;
                        }
                    } else {
                        // Drop Down
                        break; 
                    }
                }
                // Drop down to i-1
            }

            log(`Target ${target} not found.`, 'warn');
            isAnimating = false;
        }

        function highlightNode(val, level) {
            const el = document.querySelector(`.sl-node[data-val="${val}"][data-level="${level}"]`);
            if (el) {
                el.classList.add('visited');
                el.classList.add('highlight');
                setTimeout(() => el.classList.remove('highlight'), 500);
            }
        }

        function renderSkipList() {
            const container = document.getElementById('sl-canvas');
            container.innerHTML = '';

            // Create rows for levels
            for (let i = MAX_LEVEL - 1; i >= 0; i--) {
                const row = document.createElement('div');
                row.className = 'skiplist-level';
                
                const label = document.createElement('div');
                label.className = 'level-label';
                label.innerText = `Level ${i}`;
                row.appendChild(label);

                // Line
                const line = document.createElement('div');
                line.className = 'sl-line';
                row.appendChild(line);

                // Head Node
                const headNode = document.createElement('div');
                headNode.className = 'sl-node head';
                headNode.innerText = 'H';
                headNode.style.left = '80px';
                headNode.dataset.val = -Infinity;
                headNode.dataset.level = i;
                row.appendChild(headNode);

                // Data Nodes
                let leftPos = 140;
                slNodes.forEach(node => {
                    if (node.level >= i) {
                        const n = document.createElement('div');
                        n.className = 'sl-node';
                        n.innerText = node.val;
                        n.style.left = `${leftPos}px`;
                        n.dataset.val = node.val;
                        n.dataset.level = i;
                        row.appendChild(n);
                    }
                    leftPos += 60; // Fixed spacing for simplicity
                });

                container.appendChild(row);
            }
        }

        // --- LRU Logic ---
        let lruCache = []; // Array of keys
        const CAPACITY = 5;

        function lruAccess() {
            const key = document.getElementById('lruInput').value.toUpperCase();
            if (!key) return;

            const idx = lruCache.indexOf(key);
            if (idx !== -1) {
                // Hit
                lruCache.splice(idx, 1);
                lruCache.unshift(key);
                log(`LRU: Hit Key ${key}. Moved to Head.`);
            } else {
                // Miss
                if (lruCache.length >= CAPACITY) {
                    const evicted = lruCache.pop();
                    log(`LRU: Cache Full. Evicted Key ${evicted}.`, 'warn');
                }
                lruCache.unshift(key);
                log(`LRU: Inserted Key ${key}.`);
            }
            renderLRU();
        }

        function renderLRU() {
            const container = document.getElementById('lru-box');
            container.innerHTML = '';
            
            lruCache.forEach((key, index) => {
                const item = document.createElement('div');
                item.className = 'lru-item';
                if (index === 0) item.classList.add('new');
                
                item.innerHTML = `
                    <span>${key}</span>
                    <span class="tag">${index === 0 ? 'MRU' : (index === lruCache.length - 1 ? 'LRU' : '')}</span>
                `;
                container.appendChild(item);
            });
        }

        // Init
        slInsert(); slInsert(); slInsert(); // Add some initial data
        renderSkipList();
        renderLRU();

    </script>
</body>
</html>