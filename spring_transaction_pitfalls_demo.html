<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spring Transaction Pitfalls</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1 { color: #d82c20; }
        
        .container { width: 100%; max-width: 900px; display: flex; flex-direction: column; gap: 20px; }
        
        .scenario-card { 
            background: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow: hidden;
            border-left: 5px solid #d82c20; transition: all 0.3s;
        }
        .scenario-card.fixed { border-left-color: #28a745; }
        
        .card-header { 
            padding: 15px 20px; background: #f8f9fa; font-weight: bold; font-size: 1.1rem; 
            display: flex; justify-content: space-between; align-items: center; cursor: pointer;
        }
        .card-body { padding: 20px; display: none; }
        .card-body.open { display: block; }
        
        .code-block { 
            background: #2d2d2d; color: #ccc; padding: 15px; border-radius: 4px; font-family: monospace; 
            margin: 10px 0; white-space: pre-wrap; position: relative;
        }
        
        .explanation { color: #555; line-height: 1.6; margin-bottom: 10px; }
        
        .btn-fix { 
            background: #28a745; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; 
            font-size: 0.9rem; margin-top: 10px;
        }
        .btn-fix:hover { background: #218838; }
        
        .status-badge { padding: 4px 8px; border-radius: 4px; font-size: 0.8rem; color: white; background: #d82c20; }
        .fixed .status-badge { background: #28a745; }

    </style>
</head>
<body>
    <h1>Transaction Pitfalls: Why is @Transactional ignored?</h1>
    <p style="max-width: 800px; text-align: center; color: #666;">
        Common scenarios where Spring Transactions fail to rollback or even start. Click on a scenario to explore.
    </p>

    <div class="container" id="container">
        <!-- Scenarios generated by JS -->
    </div>

    <div class="container" style="margin-top: 30px;">
        <div class="scenario-card" style="border-left-color: #007bff;">
            <div class="card-header" style="background: #e3f2fd;">
                <span>üéì Interview Deep Dive: Transaction Concepts</span>
            </div>
            <div class="card-body open">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <strong>Propagation Misconceptions</strong>
                        <ul style="font-size: 0.9rem; color: #555; padding-left: 20px;">
                            <li><code>REQUIRED</code> (Default): Join existing tx or create new.</li>
                            <li><code>REQUIRES_NEW</code>: Always create new (suspend existing). ‚ö†Ô∏è Risk: Deadlock if resources overlap.</li>
                            <li><code>NESTED</code>: Savepoint (JDBC only). Rollback child doesn't affect parent.</li>
                        </ul>
                    </div>
                    <div>
                        <strong>Declarative vs Programmatic</strong>
                        <ul style="font-size: 0.9rem; color: #555; padding-left: 20px;">
                            <li><strong>Declarative (@Transactional)</strong>: Easy, AOP-based. ‚ùå Granularity is method-level.</li>
                            <li><strong>Programmatic (TransactionTemplate)</strong>: Harder code. ‚úÖ Granularity is block-level (better performance).</li>
                        </ul>
                    </div>
                </div>
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #eee;">
                    <strong>üí° Troubleshooting Tip:</strong>
                    <span style="font-size: 0.9rem; color: #555;">Enable logging <code>logging.level.org.springframework.transaction=DEBUG</code> to see transaction boundaries and rollbacks.</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const scenarios = [
            {
                id: 1,
                title: "Self-Invocation (The 'this' Trap)",
                desc: "Calling a @Transactional method from another method within the SAME class bypasses the proxy.",
                badCode: `
@Service
public class UserService {

    public void register() {
        // ... logic ...
        createUser(); // CALLS 'this.createUser()'
    }

    @Transactional
    public void createUser() {
        repo.save(user);
        throw new RuntimeException("Fail!"); 
        // ROLLBACK WILL NOT HAPPEN because register() called 'this', not the proxy.
    }
}`,
                goodCode: `
@Service
public class UserService {

    @Autowired
    private UserService self; // Inject self (Circular dep handled by Spring)

    public void register() {
        // ... logic ...
        self.createUser(); // CALLS Proxy
    }

    @Transactional
    public void createUser() {
        repo.save(user);
        throw new RuntimeException("Fail!"); 
        // ROLLBACK WORKS!
    }
}
// OR: Move createUser() to a different Service.`,
                fixed: false
            },
            {
                id: 2,
                title: "Private Method",
                desc: "Spring AOP (CGLIB/JDK) cannot proxy private methods. @Transactional is ignored.",
                badCode: `
@Service
public class UserService {

    @Transactional // IGNORED
    private void helper() {
        repo.save(data);
    }
}`,
                goodCode: `
@Service
public class UserService {

    @Transactional // WORKS (Must be public)
    public void helper() {
        repo.save(data);
    }
}`,
                fixed: false
            },
            {
                id: 3,
                title: "Swallowing Exceptions",
                desc: "If you catch the exception and don't rethrow it, the Transaction Manager thinks everything is fine.",
                badCode: `
@Transactional
public void transfer() {
    try {
        repo.save(a);
        int i = 1 / 0; // Error
    } catch (Exception e) {
        e.printStackTrace(); 
        // EXCEPTION SWALLOWED. COMMIT HAPPENS.
    }
}`,
                goodCode: `
@Transactional
public void transfer() {
    try {
        repo.save(a);
        int i = 1 / 0;
    } catch (Exception e) {
        e.printStackTrace();
        // Option 1: Rethrow
        throw new RuntimeException(e); 
        
        // Option 2: Manual Rollback
        // TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}`,
                fixed: false
            },
            {
                id: 4,
                title: "Checked Exceptions",
                desc: "By default, Spring only rolls back on RuntimeException (Unchecked). Checked Exceptions trigger COMMIT.",
                badCode: `
@Transactional
public void readFile() throws IOException {
    repo.save(log);
    throw new IOException("File not found"); 
    // CHECKED EXCEPTION -> COMMIT HAPPENS!
}`,
                goodCode: `
@Transactional(rollbackFor = Exception.class) // SPECIFY ROLLBACK RULE
public void readFile() throws IOException {
    repo.save(log);
    throw new IOException("File not found"); 
    // ROLLBACK HAPPENS
}`,
                fixed: false
            },
            {
                id: 5,
                title: "Not a Spring Bean",
                desc: "If the object is created via 'new', Spring doesn't know about it, so no Proxy is created.",
                badCode: `
public class Controller {
    public void doIt() {
        UserService service = new UserService(); // MANUALLY CREATED
        service.save(); // @Transactional inside is useless
    }
}`,
                goodCode: `
public class Controller {
    @Autowired // LET SPRING MANAGE IT
    private UserService service;

    public void doIt() {
        service.save(); // Proxy handles Transaction
    }
}`,
                fixed: false
            }
        ];

        function render() {
            const container = document.getElementById('container');
            container.innerHTML = '';
            scenarios.forEach(s => {
                const card = document.createElement('div');
                card.className = `scenario-card ${s.fixed ? 'fixed' : ''}`;
                card.innerHTML = `
                    <div class="card-header" onclick="toggle(${s.id})">
                        <span>${s.id}. ${s.title}</span>
                        <span class="status-badge">${s.fixed ? 'FIXED' : 'BROKEN'}</span>
                    </div>
                    <div class="card-body" id="body-${s.id}">
                        <div class="explanation">${s.desc}</div>
                        <div class="code-block">${s.fixed ? s.goodCode : s.badCode}</div>
                        <button class="btn-fix" onclick="fix(${s.id})">${s.fixed ? 'Show Broken Code' : 'Fix It!'}</button>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function toggle(id) {
            const body = document.getElementById(`body-${id}`);
            body.classList.toggle('open');
        }

        function fix(id) {
            const s = scenarios.find(x => x.id === id);
            s.fixed = !s.fixed;
            render();
            // Re-open the card
            setTimeout(() => document.getElementById(`body-${id}`).classList.add('open'), 0);
        }

        render();
    </script>
</body>
</html>