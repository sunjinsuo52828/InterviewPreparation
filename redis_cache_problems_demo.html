<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redis Cache Problems Demo</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 20px; }
        h1 { color: #d82c20; }
        
        .container { width: 100%; max-width: 1000px; display: flex; gap: 20px; }
        
        .control-panel { flex: 1; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .visual-panel { flex: 2; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); position: relative; min-height: 400px; }
        
        .component { 
            width: 120px; height: 80px; border-radius: 8px; display: flex; align-items: center; justify-content: center; 
            font-weight: bold; position: absolute; color: white;
        }
        .client { top: 20px; left: 20px; background: #333; }
        .redis { top: 150px; left: 150px; background: #d82c20; }
        .db { top: 300px; left: 300px; background: #0078d4; }
        
        .req-ball { 
            width: 15px; height: 15px; border-radius: 50%; background: #ff9800; position: absolute; 
            display: none; z-index: 10;
        }
        
        .stat-box { margin-top: 20px; padding: 10px; background: #eee; border-radius: 4px; font-family: monospace; }
        
        button { width: 100%; padding: 10px; margin-bottom: 10px; background: #eee; border: none; cursor: pointer; text-align: left; }
        button.active { background: #d82c20; color: white; }
        button:hover { opacity: 0.9; }
        
        .solution-toggle { margin-top: 10px; font-size: 0.9rem; display: flex; align-items: center; gap: 10px; }

    </style>
</head>
<body>
    <h1>Redis Cache Problems</h1>
    
    <div class="container">
        <div class="control-panel">
            <h3>Scenarios</h3>
            <button onclick="setScenario('NORMAL')" id="btn-normal" class="active">Normal Flow</button>
            <button onclick="setScenario('PENETRATION')" id="btn-penetration">Cache Penetration (穿透)</button>
            <button onclick="setScenario('AVALANCHE')" id="btn-avalanche">Cache Avalanche (雪崩)</button>
            <button onclick="setScenario('BREAKDOWN')" id="btn-breakdown">Cache Breakdown (击穿)</button>
            
            <div class="solution-toggle">
                <input type="checkbox" id="chk-solution">
                <label for="chk-solution">Enable Solution</label>
            </div>
            <div id="solution-desc" style="margin-top: 10px; font-size: 0.85rem; color: #28a745; font-weight: bold;"></div>
            
            <button onclick="startSim()" style="margin-top: 20px; background: #28a745; color: white; text-align: center;">Start Simulation</button>
        </div>

        <div class="visual-panel">
            <div class="component client">Client</div>
            <div class="component redis">Redis</div>
            <div class="component db">Database</div>
            
            <div id="req-container"></div>
            
            <div class="stat-box" id="stats">
                Requests: 0<br>
                Redis Hits: 0<br>
                DB Hits: 0<br>
                Status: Idle
            </div>
        </div>
    </div>

    <script>
        let scenario = 'NORMAL';
        let stats = { req: 0, redis: 0, db: 0 };
        
        function setScenario(s) {
            scenario = s;
            document.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-' + s.toLowerCase()).classList.add('active');
            updateSolutionText();
        }

        function updateSolutionText() {
            const chk = document.getElementById('chk-solution').checked;
            const div = document.getElementById('solution-desc');
            if (!chk) {
                div.innerText = "";
                return;
            }
            
            switch(scenario) {
                case 'PENETRATION': div.innerText = "Solution: Bloom Filter or Cache Null Values."; break;
                case 'AVALANCHE': div.innerText = "Solution: Randomize TTL or High Availability (Cluster)."; break;
                case 'BREAKDOWN': div.innerText = "Solution: Mutex Lock or Logical Expiry."; break;
                default: div.innerText = "";
            }
        }
        
        document.getElementById('chk-solution').addEventListener('change', updateSolutionText);

        async function startSim() {
            stats = { req: 0, redis: 0, db: 0 };
            updateStats("Running...");
            
            const count = (scenario === 'AVALANCHE' || scenario === 'BREAKDOWN') ? 20 : 5;
            const delay = (scenario === 'AVALANCHE') ? 50 : 300;
            
            for (let i = 0; i < count; i++) {
                spawnRequest();
                await wait(delay);
            }
            
            setTimeout(() => updateStats("Finished"), 2000);
        }

        async function spawnRequest() {
            const ball = document.createElement('div');
            ball.className = 'req-ball';
            ball.style.top = '60px'; ball.style.left = '80px'; ball.style.display = 'block';
            document.getElementById('req-container').appendChild(ball);
            
            stats.req++;
            updateStats("Running...");

            // Move to Redis
            await animate(ball, 60, 80, 190, 210);
            
            let hitRedis = false;
            const solution = document.getElementById('chk-solution').checked;

            if (scenario === 'NORMAL') {
                hitRedis = Math.random() > 0.3; // 70% hit rate
            } else if (scenario === 'PENETRATION') {
                // Querying non-existent key
                if (solution) {
                    // Bloom filter catches it before DB, or Cache Null returns immediately
                    // Let's simulate Cache Null hit
                    hitRedis = true; 
                } else {
                    hitRedis = false; // Always miss
                }
            } else if (scenario === 'AVALANCHE') {
                // All keys expired
                hitRedis = false; 
                if (solution) {
                    // Random TTL means some might still be there, but for visual simplicity, 
                    // let's say solution prevents the DB spike by some mechanism (like rate limiting or fallback)
                    // Or simply: Random TTL prevents ALL from expiring. So some hit.
                    hitRedis = Math.random() > 0.5;
                }
            } else if (scenario === 'BREAKDOWN') {
                // Hot key expired. Concurrent requests.
                // First one misses, others might wait (Mutex)
                // Without solution: All miss and hit DB
                hitRedis = false;
                if (solution) {
                    // Mutex: Only 1 hits DB, others wait and then hit Redis.
                    // Visualizing this is hard. Let's say 80% hit Redis (simulating waiting).
                    hitRedis = Math.random() > 0.2;
                }
            }

            if (hitRedis) {
                ball.style.background = '#28a745'; // Green for hit
                stats.redis++;
                await wait(200);
                ball.remove();
            } else {
                ball.style.background = '#d82c20'; // Red for miss
                // Move to DB
                await animate(ball, 190, 210, 340, 360);
                stats.db++;
                await wait(200);
                ball.remove();
            }
            updateStats("Running...");
        }

        function animate(el, y1, x1, y2, x2) {
            return new Promise(resolve => {
                let start = null;
                function step(timestamp) {
                    if (!start) start = timestamp;
                    const progress = Math.min((timestamp - start) / 500, 1);
                    el.style.top = y1 + (y2 - y1) * progress + 'px';
                    el.style.left = x1 + (x2 - x1) * progress + 'px';
                    if (progress < 1) {
                        window.requestAnimationFrame(step);
                    } else {
                        resolve();
                    }
                }
                window.requestAnimationFrame(step);
            });
        }

        function wait(ms) { return new Promise(r => setTimeout(r, ms)); }

        function updateStats(status) {
            document.getElementById('stats').innerHTML = `
                Requests: ${stats.req}<br>
                Redis Hits: ${stats.redis}<br>
                DB Hits: ${stats.db}<br>
                Status: ${status}
            `;
        }
    </script>
</body>
</html>